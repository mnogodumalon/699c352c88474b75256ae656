# Scaffold Context — Generated File Contents

These files are pre-generated. Do NOT Read them — their contents are below.
EXCEPTION: DashboardOverview.tsx is NOT included here. You MUST Read it with the Read tool before Write.
Your job: Analyze data (1-2 sentences), Edit Layout.tsx (title), Read then Write DashboardOverview.tsx (once), Deploy.
index.css is pre-generated with the shared design system. Do NOT edit it.
src/config/ai-features.ts is editable — set AI_PHOTO_SCAN['Entity'] = true to enable photo scan in dialogs.
NEVER use Bash cat/echo/heredoc for file operations — always use Read/Write/Edit tools.

Generated 23 scaffold files:
  - src/App.tsx
  - src/components/Layout.tsx
  - src/components/PageShell.tsx
  - src/pages/DashboardOverview.tsx
  - src/components/ConfirmDialog.tsx
  - src/components/StatCard.tsx
  - src/index.css
  - src/lib/ai.ts
  - src/lib/chat-context.ts
  - src/components/ChatWidget.tsx
  - src/config/ai-features.ts
  - src/lib/formatters.ts
  - src/hooks/useDashboardData.ts
  - src/types/enriched.ts
  - src/lib/enrich.ts
  - src/pages/ZutatendatenbankPage.tsx
  - src/components/dialogs/ZutatendatenbankDialog.tsx
  - src/pages/AnalysenPage.tsx
  - src/components/dialogs/AnalysenDialog.tsx
  - src/pages/AnalyseergebnissePage.tsx
  - src/components/dialogs/AnalyseergebnisseDialog.tsx
  - src/pages/SchnellanalysePage.tsx
  - src/components/dialogs/SchnellanalyseDialog.tsx

## src/types/app.ts
```
// AUTOMATICALLY GENERATED TYPES - DO NOT EDIT

export interface Zutatendatenbank {
  record_id: string;
  createdat: string;
  updatedat: string | null;
  fields: {
    zutat_name?: string;
    kategorie?: 'fleisch_fisch' | 'sonstiges' | 'nuesse_samen' | 'konservierungsstoffe' | 'farbstoffe' | 'aromen' | 'gewuerze_kraeuter' | 'getreide_mehl' | 'zucker_suessungsmittel' | 'fette_oele' | 'milchprodukte' | 'fruechte_gemuese' | 'eier' | 'zusatzstoffe';
    ist_allergen?: boolean;
    allergen_typ?: ('gluten' | 'krebstiere' | 'eier' | 'fisch' | 'erdnuesse' | 'soja' | 'milch_laktose' | 'schalenfruechte' | 'sellerie' | 'senf' | 'sesam' | 'lupinen' | 'weichtiere' | 'schwefeldioxid_sulfite')[];
    gesundheitsbewertung?: 'sehr_gut' | 'gut' | 'neutral' | 'bedenklich' | 'schaedlich';
    naehrwert_hinweise?: string;
    bemerkungen?: string;
  };
}

export interface Analysen {
  record_id: string;
  createdat: string;
  updatedat: string | null;
  fields: {
    analyse_titel?: string;
    produktbild?: string;
    analysedatum?: string; // Format: YYYY-MM-DD oder ISO String
    gesamtbewertung?: 'sehr_empfehlenswert' | 'empfehlenswert' | 'akzeptabel' | 'nicht_empfehlenswert' | 'bedenklich';
    allgemeine_notizen?: string;
  };
}

export interface Analyseergebnisse {
  record_id: string;
  createdat: string;
  updatedat: string | null;
  fields: {
    zugehoerende_analyse?: string; // applookup -> URL zu 'Analysen' Record
    erkannte_zutat?: string; // applookup -> URL zu 'Zutatendatenbank' Record
    menge_anteil?: string;
    einzelbewertung?: 'allergen_vorhanden' | 'positiv' | 'neutral' | 'negativ';
    bemerkung_zutat?: string;
  };
}

export interface Schnellanalyse {
  record_id: string;
  createdat: string;
  updatedat: string | null;
  fields: {
    schnell_titel?: string;
    schnell_bild?: string;
    schnell_datum?: string; // Format: YYYY-MM-DD oder ISO String
    erkannte_zutaten?: string; // applookup -> URL zu 'Zutatendatenbank' Record
    schnell_menge?: string;
    schnell_gesamtbewertung?: 'sehr_empfehlenswert' | 'empfehlenswert' | 'akzeptabel' | 'nicht_empfehlenswert' | 'bedenklich';
    schnell_notizen?: string;
  };
}

export const APP_IDS = {
  ZUTATENDATENBANK: '699c35017ca9d5e746867983',
  ANALYSEN: '699c3506b5c37b2fe49da856',
  ANALYSEERGEBNISSE: '699c350783673810f82e34c4',
  SCHNELLANALYSE: '699c35083159889d7927b682',
} as const;

// Helper Types for creating new records
export type CreateZutatendatenbank = Zutatendatenbank['fields'];
export type CreateAnalysen = Analysen['fields'];
export type CreateAnalyseergebnisse = Analyseergebnisse['fields'];
export type CreateSchnellanalyse = Schnellanalyse['fields'];
```

## src/services/livingAppsService.ts
```
// AUTOMATICALLY GENERATED SERVICE
import { APP_IDS } from '@/types/app';
import type { Zutatendatenbank, Analysen, Analyseergebnisse, Schnellanalyse } from '@/types/app';

// Base Configuration
const API_BASE_URL = 'https://my.living-apps.de/rest';

// --- HELPER FUNCTIONS ---
export function extractRecordId(url: string | null | undefined): string | null {
  if (!url) return null;
  // Extrahiere die letzten 24 Hex-Zeichen mit Regex
  const match = url.match(/([a-f0-9]{24})$/i);
  return match ? match[1] : null;
}

export function createRecordUrl(appId: string, recordId: string): string {
  return `https://my.living-apps.de/rest/apps/${appId}/records/${recordId}`;
}

async function callApi(method: string, endpoint: string, data?: any) {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    method,
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',  // Nutze Session Cookies für Auth
    body: data ? JSON.stringify(data) : undefined
  });
  if (!response.ok) throw new Error(await response.text());
  // DELETE returns often empty body or simple status
  if (method === 'DELETE') return true;
  return response.json();
}

export class LivingAppsService {
  // --- ZUTATENDATENBANK ---
  static async getZutatendatenbank(): Promise<Zutatendatenbank[]> {
    const data = await callApi('GET', `/apps/${APP_IDS.ZUTATENDATENBANK}/records`);
    return Object.entries(data).map(([id, rec]: [string, any]) => ({
      record_id: id, ...rec
    }));
  }
  static async getZutatendatenbankEntry(id: string): Promise<Zutatendatenbank | undefined> {
    const data = await callApi('GET', `/apps/${APP_IDS.ZUTATENDATENBANK}/records/${id}`);
    return { record_id: data.id, ...data };
  }
  static async createZutatendatenbankEntry(fields: Zutatendatenbank['fields']) {
    return callApi('POST', `/apps/${APP_IDS.ZUTATENDATENBANK}/records`, { fields });
  }
  static async updateZutatendatenbankEntry(id: string, fields: Partial<Zutatendatenbank['fields']>) {
    return callApi('PATCH', `/apps/${APP_IDS.ZUTATENDATENBANK}/records/${id}`, { fields });
  }
  static async deleteZutatendatenbankEntry(id: string) {
    return callApi('DELETE', `/apps/${APP_IDS.ZUTATENDATENBANK}/records/${id}`);
  }

  // --- ANALYSEN ---
  static async getAnalysen(): Promise<Analysen[]> {
    const data = await callApi('GET', `/apps/${APP_IDS.ANALYSEN}/records`);
    return Object.entries(data).map(([id, rec]: [string, any]) => ({
      record_id: id, ...rec
    }));
  }
  static async getAnalysenEntry(id: string): Promise<Analysen | undefined> {
    const data = await callApi('GET', `/apps/${APP_IDS.ANALYSEN}/records/${id}`);
    return { record_id: data.id, ...data };
  }
  static async createAnalysenEntry(fields: Analysen['fields']) {
    return callApi('POST', `/apps/${APP_IDS.ANALYSEN}/records`, { fields });
  }
  static async updateAnalysenEntry(id: string, fields: Partial<Analysen['fields']>) {
    return callApi('PATCH', `/apps/${APP_IDS.ANALYSEN}/records/${id}`, { fields });
  }
  static async deleteAnalysenEntry(id: string) {
    return callApi('DELETE', `/apps/${APP_IDS.ANALYSEN}/records/${id}`);
  }

  // --- ANALYSEERGEBNISSE ---
  static async getAnalyseergebnisse(): Promise<Analyseergebnisse[]> {
    const data = await callApi('GET', `/apps/${APP_IDS.ANALYSEERGEBNISSE}/records`);
    return Object.entries(data).map(([id, rec]: [string, any]) => ({
      record_id: id, ...rec
    }));
  }
  static async getAnalyseergebnisseEntry(id: string): Promise<Analyseergebnisse | undefined> {
    const data = await callApi('GET', `/apps/${APP_IDS.ANALYSEERGEBNISSE}/records/${id}`);
    return { record_id: data.id, ...data };
  }
  static async createAnalyseergebnisseEntry(fields: Analyseergebnisse['fields']) {
    return callApi('POST', `/apps/${APP_IDS.ANALYSEERGEBNISSE}/records`, { fields });
  }
  static async updateAnalyseergebnisseEntry(id: string, fields: Partial<Analyseergebnisse['fields']>) {
    return callApi('PATCH', `/apps/${APP_IDS.ANALYSEERGEBNISSE}/records/${id}`, { fields });
  }
  static async deleteAnalyseergebnisseEntry(id: string) {
    return callApi('DELETE', `/apps/${APP_IDS.ANALYSEERGEBNISSE}/records/${id}`);
  }

  // --- SCHNELLANALYSE ---
  static async getSchnellanalyse(): Promise<Schnellanalyse[]> {
    const data = await callApi('GET', `/apps/${APP_IDS.SCHNELLANALYSE}/records`);
    return Object.entries(data).map(([id, rec]: [string, any]) => ({
      record_id: id, ...rec
    }));
  }
  static async getSchnellanalyseEntry(id: string): Promise<Schnellanalyse | undefined> {
    const data = await callApi('GET', `/apps/${APP_IDS.SCHNELLANALYSE}/records/${id}`);
    return { record_id: data.id, ...data };
  }
  static async createSchnellanalyseEntry(fields: Schnellanalyse['fields']) {
    return callApi('POST', `/apps/${APP_IDS.SCHNELLANALYSE}/records`, { fields });
  }
  static async updateSchnellanalyseEntry(id: string, fields: Partial<Schnellanalyse['fields']>) {
    return callApi('PATCH', `/apps/${APP_IDS.SCHNELLANALYSE}/records/${id}`, { fields });
  }
  static async deleteSchnellanalyseEntry(id: string) {
    return callApi('DELETE', `/apps/${APP_IDS.SCHNELLANALYSE}/records/${id}`);
  }

}
```

## src/App.tsx
```
import { HashRouter, Routes, Route } from 'react-router-dom';
import { Layout } from '@/components/Layout';
import DashboardOverview from '@/pages/DashboardOverview';
import ZutatendatenbankPage from '@/pages/ZutatendatenbankPage';
import AnalysenPage from '@/pages/AnalysenPage';
import AnalyseergebnissePage from '@/pages/AnalyseergebnissePage';
import SchnellanalysePage from '@/pages/SchnellanalysePage';

export default function App() {
  return (
    <HashRouter>
      <Routes>
        <Route element={<Layout />}>
          <Route index element={<DashboardOverview />} />
          <Route path="zutatendatenbank" element={<ZutatendatenbankPage />} />
          <Route path="analysen" element={<AnalysenPage />} />
          <Route path="analyseergebnisse" element={<AnalyseergebnissePage />} />
          <Route path="schnellanalyse" element={<SchnellanalysePage />} />
        </Route>
      </Routes>
    </HashRouter>
  );
}
```

## src/components/Layout.tsx
```
import { NavLink, Outlet } from 'react-router-dom';
import { FileText, LayoutDashboard, Menu, X } from 'lucide-react';
import { useState } from 'react';
import ChatWidget from '@/components/ChatWidget';

// ⚡ Customize these for your app
const APP_TITLE = 'Dashboard';
const APP_SUBTITLE = 'Verwaltung';

const navigation = [
  { name: 'Übersicht', href: '/', icon: LayoutDashboard },
  { name: 'Zutatendatenbank', href: '/zutatendatenbank', icon: FileText },
  { name: 'Analysen', href: '/analysen', icon: FileText },
  { name: 'Analyseergebnisse', href: '/analyseergebnisse', icon: FileText },
  { name: 'Schnellanalyse', href: '/schnellanalyse', icon: FileText },
];

export function Layout() {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className="min-h-screen bg-background">
      {sidebarOpen && (
        <div
          className="fixed inset-0 bg-black/50 backdrop-blur-sm z-40 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}

      <aside
        className={`
          fixed top-0 left-0 z-50 h-full w-64 bg-sidebar border-r border-sidebar-border
          transform transition-transform duration-200 ease-in-out
          ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}
          lg:translate-x-0
        `}
      >
        <div className="flex items-center justify-between px-5 py-6 border-b border-sidebar-border">
          <div className="flex items-center gap-3">
            <div className="w-9 h-9 rounded-xl bg-sidebar-primary flex items-center justify-center shadow-sm">
              <FileText size={16} className="text-sidebar-primary-foreground" />
            </div>
            <div>
              <h1 className="text-sm font-bold tracking-tight text-sidebar-foreground">{APP_TITLE}</h1>
              <p className="text-xs text-sidebar-foreground/60">{APP_SUBTITLE}</p>
            </div>
          </div>
          <button
            className="lg:hidden p-1.5 rounded-lg text-sidebar-foreground/60 hover:text-sidebar-foreground transition-colors"
            onClick={() => setSidebarOpen(false)}
          >
            <X size={16} />
          </button>
        </div>
        <nav className="px-3 pt-4 space-y-0.5">
          <p className="px-3 pb-2 text-xs font-semibold uppercase tracking-widest text-sidebar-foreground/40">
            Navigation
          </p>
          {navigation.map(item => (
            <NavLink
              key={item.href}
              to={item.href}
              end={item.href === '/'}
              onClick={() => setSidebarOpen(false)}
              className={({ isActive }: { isActive: boolean }) =>
                `flex items-center gap-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-colors ${
                  isActive
                    ? 'bg-sidebar-primary text-sidebar-primary-foreground shadow-sm'
                    : 'text-sidebar-foreground/70 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground'
                }`
              }
            >
              <item.icon size={16} className="shrink-0" />
              {item.name}
            </NavLink>
          ))}
        </nav>
      </aside>

      <div className="lg:pl-64">
        <header className="lg:hidden flex items-center gap-4 px-4 py-3 border-b bg-card sticky top-0 z-30">
          <button
            className="p-2 rounded-lg hover:bg-accent transition-colors"
            onClick={() => setSidebarOpen(true)}
          >
            <Menu size={18} />
          </button>
          <span className="font-semibold text-sm">{APP_TITLE}</span>
        </header>
        <main className="p-6 lg:p-8 max-w-screen-2xl">
          <Outlet />
        </main>
      </div>

      <ChatWidget />
    </div>
  );
}
```

## src/hooks/useDashboardData.ts
```
import { useState, useEffect, useMemo, useCallback } from 'react';
import type { Zutatendatenbank, Analysen, Analyseergebnisse, Schnellanalyse } from '@/types/app';
import { LivingAppsService } from '@/services/livingAppsService';

export function useDashboardData() {
  const [zutatendatenbank, setZutatendatenbank] = useState<Zutatendatenbank[]>([]);
  const [analysen, setAnalysen] = useState<Analysen[]>([]);
  const [analyseergebnisse, setAnalyseergebnisse] = useState<Analyseergebnisse[]>([]);
  const [schnellanalyse, setSchnellanalyse] = useState<Schnellanalyse[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchAll = useCallback(async () => {
    setError(null);
    try {
      const [zutatendatenbankData, analysenData, analyseergebnisseData, schnellanalyseData] = await Promise.all([
        LivingAppsService.getZutatendatenbank(),
        LivingAppsService.getAnalysen(),
        LivingAppsService.getAnalyseergebnisse(),
        LivingAppsService.getSchnellanalyse(),
      ]);
      setZutatendatenbank(zutatendatenbankData);
      setAnalysen(analysenData);
      setAnalyseergebnisse(analyseergebnisseData);
      setSchnellanalyse(schnellanalyseData);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Fehler beim Laden der Daten'));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchAll(); }, [fetchAll]);

  const zutatendatenbankMap = useMemo(() => {
    const m = new Map<string, Zutatendatenbank>();
    zutatendatenbank.forEach(r => m.set(r.record_id, r));
    return m;
  }, [zutatendatenbank]);

  const analysenMap = useMemo(() => {
    const m = new Map<string, Analysen>();
    analysen.forEach(r => m.set(r.record_id, r));
    return m;
  }, [analysen]);

  return { zutatendatenbank, setZutatendatenbank, analysen, setAnalysen, analyseergebnisse, setAnalyseergebnisse, schnellanalyse, setSchnellanalyse, loading, error, fetchAll, zutatendatenbankMap, analysenMap };
}
```

## src/types/enriched.ts
```
import type { Analyseergebnisse, Schnellanalyse } from './app';

export type EnrichedAnalyseergebnisse = Analyseergebnisse & {
  zugehoerende_analyseName: string;
  erkannte_zutatName: string;
};

export type EnrichedSchnellanalyse = Schnellanalyse & {
  erkannte_zutatenName: string;
};

```

## src/lib/enrich.ts
```
import type { EnrichedAnalyseergebnisse, EnrichedSchnellanalyse } from '@/types/enriched';
import type { Analyseergebnisse, Analysen, Schnellanalyse, Zutatendatenbank } from '@/types/app';
import { extractRecordId } from '@/services/livingAppsService';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function resolveDisplay(url: string | undefined, map: Map<string, any>, ...fields: string[]): string {
  if (!url) return '';
  const id = extractRecordId(url);
  if (!id) return '';
  const r = map.get(id);
  if (!r) return '';
  return fields.map(f => String(r.fields[f] ?? '')).join(' ').trim();
}

interface AnalyseergebnisseMaps {
  analysenMap: Map<string, Analysen>;
  zutatendatenbankMap: Map<string, Zutatendatenbank>;
}

export function enrichAnalyseergebnisse(
  analyseergebnisse: Analyseergebnisse[],
  maps: AnalyseergebnisseMaps
): EnrichedAnalyseergebnisse[] {
  return analyseergebnisse.map(r => ({
    ...r,
    zugehoerende_analyseName: resolveDisplay(r.fields.zugehoerende_analyse, maps.analysenMap, 'analyse_titel'),
    erkannte_zutatName: resolveDisplay(r.fields.erkannte_zutat, maps.zutatendatenbankMap, 'zutat_name'),
  }));
}

interface SchnellanalyseMaps {
  zutatendatenbankMap: Map<string, Zutatendatenbank>;
}

export function enrichSchnellanalyse(
  schnellanalyse: Schnellanalyse[],
  maps: SchnellanalyseMaps
): EnrichedSchnellanalyse[] {
  return schnellanalyse.map(r => ({
    ...r,
    erkannte_zutatenName: resolveDisplay(r.fields.erkannte_zutaten, maps.zutatendatenbankMap, 'zutat_name'),
  }));
}

```

## src/lib/formatters.ts
```
import { format, parseISO } from 'date-fns';
import { de } from 'date-fns/locale';

export function formatDate(s: string | undefined) {
  if (!s) return '—';
  try { return format(parseISO(s), 'dd.MM.yyyy', { locale: de }); } catch { return s; }
}

export function formatCurrency(v: number | undefined) {
  if (v == null) return '—';
  return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(v);
}

/** Extract display label from lookup/select or lookup/radio API response */
export function displayLookup(val: unknown): string {
  if (val == null) return '—';
  if (typeof val === 'object' && val !== null && 'label' in val) return String((val as Record<string, unknown>).label);
  return String(val);
}

/** Extract labels from multiplelookup/checkbox API response */
export function displayMultiLookup(val: unknown): string {
  if (val == null) return '—';
  if (Array.isArray(val)) return val.map(v => typeof v === 'object' && v !== null && 'label' in v ? String((v as Record<string, unknown>).label) : String(v)).join(', ') || '—';
  return displayLookup(val);
}

/** Extract key from lookup value (handles both {key,label} objects and plain strings) */
export function lookupKey(val: unknown): string | undefined {
  if (val == null) return undefined;
  if (typeof val === 'object' && val !== null && 'key' in val) return String((val as Record<string, unknown>).key);
  if (typeof val === 'string') return val;
  return undefined;
}

/** Extract keys from multiplelookup value */
export function lookupKeys(val: unknown): string[] {
  if (!Array.isArray(val)) return [];
  return val.map(v => typeof v === 'object' && v !== null && 'key' in v ? String((v as Record<string, unknown>).key) : String(v));
}
```

## src/lib/ai.ts
```
const AI_ENDPOINT = "https://my.living-apps.de/litellm/v1/chat/completions";
const AI_MODEL = "default";

export type ChatMessage = {
  role: "system" | "user" | "assistant";
  content: string | Array<{ type: string; [key: string]: unknown }>;
};

type CompletionOptions = {
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
  stop?: string[];
  response_format?: { type: string };
};

export async function chatCompletion(
  messages: ChatMessage[],
  options: CompletionOptions = {}
): Promise<string> {
  const res = await fetch(AI_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json", Accept: "application/json" },
    body: JSON.stringify({ model: AI_MODEL, messages, ...options }),
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`AI API ${res.status}: ${body}`);
  }
  const data = await res.json();
  return data.choices[0].message.content;
}

export async function safeJsonCompletion<T = unknown>(
  messages: ChatMessage[],
  options: CompletionOptions = {}
): Promise<T> {
  const raw = await chatCompletion(messages, options);
  const match = raw.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
  if (!match) throw new Error(`Expected JSON but got: ${raw.slice(0, 200)}`);
  return JSON.parse(match[0]);
}

export async function withRetry<T>(fn: () => Promise<T>, maxAttempts = 3): Promise<T> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (err) {
      if (attempt === maxAttempts) throw err;
      await new Promise((r) => setTimeout(r, 1000 * attempt));
    }
  }
  throw new Error("unreachable");
}

// --- File encoding helpers ---

export function fileToDataUri(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error("Failed to read file"));
    reader.readAsDataURL(file);
  });
}

export async function urlToDataUri(url: string): Promise<string> {
  const res = await fetch(url);
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error("Failed to encode file"));
    reader.readAsDataURL(blob);
  });
}

// --- High-level AI features ---

export async function classify(
  text: string,
  categories: string[]
): Promise<{ category: string; confidence: number }> {
  return safeJsonCompletion([
    {
      role: "system",
      content: [
        "You are a classifier. Respond ONLY with valid JSON, nothing else.",
        'Output format: {"category": "<one of the allowed categories>", "confidence": <0-1>}',
        `Allowed categories: ${JSON.stringify(categories)}`,
      ].join("\n"),
    },
    { role: "user", content: text },
  ], { temperature: 0 });
}

export async function extract<T = Record<string, unknown>>(
  text: string,
  schemaDescription: string
): Promise<T> {
  return safeJsonCompletion([
    {
      role: "system",
      content: [
        "You are a data extraction engine. Respond ONLY with valid JSON matching the requested schema.",
        "If a field cannot be determined from the input, use null.",
        `Schema:\n${schemaDescription}`,
      ].join("\n"),
    },
    { role: "user", content: text },
  ], { temperature: 0 });
}

export async function summarize(
  text: string,
  options: { maxSentences?: number; language?: string } = {}
): Promise<string> {
  const { maxSentences = 3, language } = options;
  const instructions = [
    `Summarize the following text in at most ${maxSentences} sentences.`,
    "Be concise and preserve key facts.",
  ];
  if (language) instructions.push(`Write the summary in ${language}.`);
  return chatCompletion([
    { role: "system", content: instructions.join(" ") },
    { role: "user", content: text },
  ]);
}

export async function translate(
  text: string,
  targetLanguage: string,
  sourceLanguage?: string
): Promise<string> {
  const from = sourceLanguage ? ` from ${sourceLanguage}` : "";
  return chatCompletion([
    {
      role: "system",
      content: `Translate the following text${from} to ${targetLanguage}. Output ONLY the translation, nothing else.`,
    },
    { role: "user", content: text },
  ]);
}

export async function analyzeImage(imageDataUri: string, prompt: string): Promise<string> {
  return chatCompletion([
    {
      role: "user",
      content: [
        { type: "text", text: prompt },
        { type: "image_url", image_url: { url: imageDataUri } },
      ],
    },
  ]);
}

export async function analyzeDocument(fileDataUri: string, prompt: string): Promise<string> {
  return chatCompletion([
    {
      role: "user",
      content: [
        { type: "text", text: prompt },
        { type: "file", file: { file_data: fileDataUri } },
      ],
    },
  ]);
}

export async function extractFromPhoto<T = Record<string, unknown>>(
  dataUri: string,
  schemaDescription: string
): Promise<T> {
  const isImage = dataUri.startsWith("data:image/");
  const fileContent = isImage
    ? { type: "image_url" as const, image_url: { url: dataUri } }
    : { type: "file" as const, file: { file_data: dataUri } };
  return safeJsonCompletion([
    {
      role: "system",
      content: [
        "Extract structured data from the provided " + (isImage ? "image" : "document") + ".",
        "Respond ONLY with valid JSON matching the schema.",
        "Use null for any field that cannot be determined.",
        `Schema:\n${schemaDescription}`,
      ].join("\n"),
    },
    {
      role: "user",
      content: [
        { type: "text", text: "Extract the data from this " + (isImage ? "image" : "document") + "." },
        fileContent,
      ],
    },
  ]);
}

```

## src/lib/chat-context.ts
```
export const CHAT_SYSTEM_PROMPT = `Du bist ein hilfreicher Assistent für diese App.\n\nDie App verwaltet folgende Daten:\n- Zutatendatenbank: Name der Zutat, Kategorie, Ist Allergen (ja/nein), Allergen-Typ, Gesundheitsbewertung, Nährwert-Hinweise, Weitere Bemerkungen\n- Analysen: Titel der Analyse, Produktbild hochladen, Analysedatum und -zeit (Datum), Gesamtbewertung, Allgemeine Notizen\n- Analyseergebnisse: Zugehörige Analyse (→ Analysen), Erkannte Zutat (→ Zutatendatenbank), Menge/Anteil, Bewertung dieser Zutat, Bemerkung zu dieser Zutat\n- Schnellanalyse: Titel der Analyse, Produktbild, Analysedatum und -zeit (Datum), Zutaten auswählen (→ Zutatendatenbank), Menge/Anteil, Gesamtbewertung des Produkts, Notizen\n\nDu kannst:\n- Fragen zur App und den Daten beantworten\n- Hochgeladene Bilder und Dokumente analysieren\n- Texte zusammenfassen oder übersetzen\n- Bei der Dateneingabe helfen\n\nAntworte kurz und präzise. Verwende die gleiche Sprache wie der Nutzer.`;

```

## src/config/ai-features.ts
```
/**
 * AI feature toggles per entity.
 * Set to true to show "Foto scannen" button in the create/edit dialog.
 * The agent can change these values — all other AI files are pre-generated.
 */

export const AI_PHOTO_SCAN: Record<string, boolean> = {
  Zutatendatenbank: true,
  Analysen: true,
  Analyseergebnisse: true,
  Schnellanalyse: true,
};
```
